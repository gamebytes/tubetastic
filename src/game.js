// Generated by CoffeeScript 1.6.3
(function() {
  var AsyncSoundManager, GameBoard, GameMenu, ProgressBar, ScoreKeeper, SeedRandom, SinkTile, SourceTile, Splash, StartButton, Tile, TileGraphics, TubeTile, TubetasticGame, d, _ref, _ref1, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  d = function(msg) {
    var _ref;
    if ((_ref = document.getElementById('debug')) != null) {
      _ref.innerHTML = msg;
    }
    return console.log(msg);
  };

  window.addEventListener('load', (function() {
    return FastClick.attach(document.body);
  }), false);

  createjs.Stage.prototype._updatePointerPosition = function(id, pageX, pageY) {
    var h, o, rect, w, _ref, _ref1;
    rect = this._getElementRect(this.canvas);
    w = this.canvas.width;
    h = this.canvas.height;
    if (isNaN(rect.left)) {
      rect.left = 0;
    }
    if (isNaN(rect.top)) {
      rect.top = 0;
    }
    if (isNaN(rect.right)) {
      rect.right = w;
    }
    if (isNaN(rect.bottom)) {
      rect.bottom = h;
    }
    pageX -= rect.left;
    pageY -= rect.top;
    pageX /= (rect.right - rect.left) / w;
    pageY /= (rect.bottom - rect.top) / h;
    o = this._getPointerData(id);
    if ((o.inBounds = pageX >= 0 && pageY >= 0 && pageX <= w - 1 && pageY <= h - 1)) {
      o.x = pageX;
      o.y = pageY;
    } else if (this.mouseMoveOutside) {
      o.x = pageX < 0 ? 0 : (_ref = pageX > w - 1) != null ? _ref : w - {
        1: pageX
      };
      o.y = pageY < 0 ? 0 : (_ref1 = pageY > h - 1) != null ? _ref1 : h - {
        1: pageY
      };
    }
    o.rawX = pageX;
    o.rawY = pageY;
    if (id === this._primaryPointerID) {
      this.mouseX = o.x;
      this.mouseY = o.y;
      return this.mouseInBounds = o.inBounds;
    }
  };

  SeedRandom = (function() {
    function SeedRandom() {}

    SeedRandom.init = function(initVector) {
      SeedRandom.initialize(window, [], Math, 256, 6, 52);
      return Math.seedrandom(initVector);
    };

    SeedRandom.initialize = function(global, pool, math, width, chunks, digits) {
      var ARC4, autoseed, flatten, mask, mixkey, overflow, significance, startdenom, tostring;
      startdenom = math.pow(width, chunks);
      significance = math.pow(2, digits);
      overflow = significance * 2;
      mask = width - 1;
      ARC4 = (function() {
        function ARC4(key) {
          this.g = __bind(this.g, this);
          var i, j, keylen, s, t, _i, _ref;
          t = key.length;
          keylen = key.length;
          i = 0;
          j = this.i = this.j = 0;
          s = this.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = _i = 0, _ref = width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
            s[j] = t;
          }
          this.g(width);
        }

        ARC4.prototype.g = function(count) {
          var i, j, r, s, t;
          r = 0;
          t = 0;
          i = this.i;
          j = this.j;
          s = this.S;
          while (count--) {
            t = s[i = mask & (i + 1)];
            r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
          }
          this.i = i;
          this.j = j;
          return r;
        };

        return ARC4;

      })();
      flatten = function(obj, depth) {
        var e, prop, result, typ;
        result = [];
        typ = (typeof obj)[0];
        if ((depth !== 0) && (typ === 'o')) {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (_error) {
              e = _error;
            }
          }
        }
        if (result.length) {
          return result;
        }
        if (typ === 's') {
          return obj;
        }
        return obj + '\0';
      };
      mixkey = function(seed, key) {
        var j, smear, stringseed;
        stringseed = seed + '';
        smear = 0;
        j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
        }
        return tostring(key);
      };
      autoseed = function(seed) {
        var e;
        try {
          global.crypto.getRandomValues(seed = new Uint8Array(width));
          return tostring(seed);
        } catch (_error) {
          e = _error;
        }
        return [+(new Date), global, global.navigator.plugins, global.screen, tostring(pool)];
      };
      tostring = function(a) {
        return String.fromCharCode.apply(0, a);
      };
      math['seedrandom'] = function(seed, use_entropy) {
        var arc4, key, shortseed, to_flatten;
        key = [];
        if (use_entropy) {
          to_flatten = [seed, tostring(pool)];
        } else if (0 in arguments) {
          to_flatten = seed;
        } else {
          to_flatten = autoseed();
        }
        shortseed = mixkey(flatten(to_flatten, 3), key);
        arc4 = new ARC4(key);
        mixkey(tostring(arc4.S), pool);
        math['random'] = function() {
          var dd, n, x;
          n = arc4.g(chunks);
          dd = startdenom;
          x = 0;
          while (n < significance) {
            n = (n + x) * width;
            dd *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            dd /= 2;
            x >>>= 1;
          }
          return (n + x) / dd;
        };
        return shortseed;
      };
      return mixkey(math.random(), pool);
    };

    return SeedRandom;

  })();

  ScoreKeeper = (function() {
    function ScoreKeeper() {}

    ScoreKeeper.setScore = function(score) {
      if (window.localStorage && (score > ScoreKeeper.getHighScore())) {
        return window.localStorage.setItem('score:high', score);
      }
    };

    ScoreKeeper.getHighScore = function() {
      var highScore;
      if (!window.localStorage) {
        return 0;
      }
      highScore = window.localStorage.getItem('score:high') || 0;
      if (isNaN(highScore)) {
        return 0;
      }
      return parseInt(highScore);
    };

    return ScoreKeeper;

  }).call(this);

  AsyncSoundManager = (function() {
    var sounds;

    function AsyncSoundManager() {}

    sounds = {};

    AsyncSoundManager.play = function(id, volume) {
      if (volume == null) {
        volume = 1.0;
      }
      if (sounds[id]) {
        createjs.Sound.play(id).setVolume(volume);
      }
      return AsyncSoundManager;
    };

    return AsyncSoundManager;

  }).call(this);

  TileGraphics = (function() {
    function TileGraphics() {}

    TileGraphics.cache = {};

    TileGraphics.resize = function() {
      return TileGraphics.cache = {};
    };

    TileGraphics.get = function(id) {
      return TileGraphics.cache[id];
    };

    TileGraphics.put = function(id, val) {
      return TileGraphics.cache[id] = val;
    };

    return TileGraphics;

  }).call(this);

  Tile = (function(_super) {
    __extends(Tile, _super);

    Tile.outletRotationsReverse = {
      0: {
        N: 'N',
        E: 'E',
        S: 'S',
        W: 'W'
      },
      90: {
        N: 'W',
        E: 'N',
        S: 'E',
        W: 'S'
      },
      180: {
        N: 'S',
        E: 'W',
        S: 'N',
        W: 'E'
      },
      270: {
        N: 'E',
        E: 'S',
        S: 'W',
        W: 'N'
      }
    };

    Tile.outletDirections = ['N', 'E', 'S', 'W'];

    Tile.outletOffsets = {
      N: {
        col: 0,
        row: -1
      },
      E: {
        col: 1,
        row: 0
      },
      S: {
        col: 0,
        row: 1
      },
      W: {
        col: -1,
        row: 0
      }
    };

    Tile.directionReverse = {
      N: 'S',
      E: 'W',
      S: 'N',
      W: 'E'
    };

    Tile.POWER_NONE = 0;

    Tile.POWER_SOURCED = 1;

    Tile.POWER_SUNK = 2;

    Tile.arcShadow = {};

    Tile.arcShadow[Tile.POWER_NONE] = null;

    Tile.arcShadow[Tile.POWER_SOURCED] = new createjs.Shadow('#ff9900', 0, 0, 8);

    Tile.arcShadow[Tile.POWER_SUNK] = new createjs.Shadow('#0099ff', 0, 0, 8);

    Tile.tileBack = {};

    Tile.tileBack[Tile.POWER_NONE] = 'rgba(255,255,255,0.25)';

    Tile.tileBack[Tile.POWER_SOURCED] = 'rgba(255,255,255,0.25)';

    Tile.tileBack[Tile.POWER_SUNK] = 'rgba(255,255,255,0.25)';

    Tile.arcColor = '#eee';

    Tile.padding = 1 / 16;

    function Tile(colNum, rowNum, x, y, s, board) {
      this.resize = __bind(this.resize, this);
      this.isSunk = __bind(this.isSunk, this);
      this.isSourced = __bind(this.isSourced, this);
      this.setPower = __bind(this.setPower, this);
      this.neighbor = __bind(this.neighbor, this);
      this.getConnectedNeighbors = __bind(this.getConnectedNeighbors, this);
      this.hasOutletTo = __bind(this.hasOutletTo, this);
      this.initialize(colNum, rowNum, x, y, s, board);
    }

    Tile.prototype.initialize = function(colNum, rowNum, x, y, s, board) {
      this.colNum = colNum;
      this.rowNum = rowNum;
      this.board = board;
      Tile.__super__.initialize.call(this);
      this.power = Tile.POWER_NONE;
      this.id = Tile.makeId(this.colNum, this.rowNum);
      this.outlets = {
        N: false,
        E: false,
        S: false,
        W: false
      };
      this.rotation = 0;
      this.outletRotation = 0;
      return this.resize(x, y, s);
    };

    Tile.prototype.hasOutletTo = function(outletDirection) {
      var hasOutlet, originalDirection;
      originalDirection = Tile.outletRotationsReverse[this.outletRotation][outletDirection];
      hasOutlet = this.outlets[originalDirection];
      return hasOutlet;
    };

    Tile.prototype.getConnectedNeighbors = function() {
      var direction, neighbor, ret, _i, _len, _ref;
      ret = {};
      _ref = Tile.outletDirections;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        direction = _ref[_i];
        if (!(this.hasOutletTo(direction))) {
          continue;
        }
        neighbor = this.neighbor(direction);
        if (!(neighbor && neighbor.hasOutletTo(Tile.directionReverse[direction]))) {
          continue;
        }
        if (neighbor) {
          ret[direction] = neighbor;
        }
      }
      return ret;
    };

    Tile.prototype.neighbor = function(outletDirection) {
      var offsets;
      offsets = Tile.outletOffsets[outletDirection];
      return this.board.tileAt(this.colNum + offsets.col, this.rowNum + offsets.row);
    };

    Tile.prototype.setPower = function(power) {
      this.power = power;
    };

    Tile.prototype.isSourced = function() {
      return this.power === Tile.POWER_SOURCED;
    };

    Tile.prototype.isSunk = function() {
      return this.power === Tile.POWER_SUNK;
    };

    Tile.makeId = function(colNum, rowNum) {
      return [colNum, rowNum].join(',');
    };

    Tile.prototype.resize = function(x, y, s) {
      this.midpoint = s / 2;
      this.x = x + this.midpoint;
      this.y = y + this.midpoint;
      this.regX = this.midpoint;
      return this.regY = this.midpoint;
    };

    return Tile;

  }).call(this, createjs.Container);

  SourceTile = (function(_super) {
    __extends(SourceTile, _super);

    function SourceTile() {
      this.resize = __bind(this.resize, this);
      this.setPower = __bind(this.setPower, this);
      _ref = SourceTile.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SourceTile.prototype.initialize = function(colNum, rowNum, x, y, s, board) {
      SourceTile.__super__.initialize.call(this, colNum, rowNum, x, y, s, board);
      this.back = null;
      this.arc = null;
      this.power = Tile.POWER_SOURCED;
      this.outlets['E'] = true;
      return this.resize(x, y, s);
    };

    SourceTile.prototype.setPower = function() {};

    SourceTile.prototype.resize = function(x, y, s) {
      var arc, back, gfxArc, gfxBack;
      SourceTile.__super__.resize.call(this, x, y, s);
      this.removeAllChildren();
      gfxBack = TileGraphics.get('sourceBack');
      if (!gfxBack) {
        gfxBack = new createjs.Graphics().beginFill(Tile.tileBack[this.power]).drawRoundRect(s * Tile.padding * 3, s * Tile.padding * 3, s * (1 - (6 * Tile.padding)), s * (1 - (6 * Tile.padding)), s * Tile.padding * 6);
        TileGraphics.put('sourceBack', gfxBack);
      }
      back = new createjs.Shape(gfxBack);
      back.shadow = Tile.arcShadow[this.power];
      this.addChild(back);
      gfxArc = TileGraphics.get('sourceArc');
      if (!gfxArc) {
        gfxArc = new createjs.Graphics().beginFill(Tile.arcColor).drawCircle(this.midpoint, this.midpoint, s / 16).drawRect(this.midpoint, this.midpoint - s / 16, this.midpoint, s / 8);
        TileGraphics.put('sourceArc', gfxArc);
      }
      arc = new createjs.Shape(gfxArc);
      arc.shadow = Tile.arcShadow[this.power];
      this.addChild(arc);
      return this;
    };

    return SourceTile;

  })(Tile);

  SinkTile = (function(_super) {
    __extends(SinkTile, _super);

    function SinkTile() {
      this.resize = __bind(this.resize, this);
      this.setPower = __bind(this.setPower, this);
      _ref1 = SinkTile.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SinkTile.prototype.initialize = function(colNum, rowNum, x, y, s, board) {
      SinkTile.__super__.initialize.call(this, colNum, rowNum, x, y, s, board);
      this.outlets['W'] = true;
      this.power = Tile.POWER_SUNK;
      return this.resize(x, y, s);
    };

    SinkTile.prototype.setPower = function(power) {
      if (power === this.power) {
        return;
      }
      if ((power === Tile.POWER_SOURCED) && this.board.settled) {
        AsyncSoundManager.play('boom');
      }
      this.arc.shadow = Tile.arcShadow[power];
      this.power = power;
      return this;
    };

    SinkTile.prototype.resize = function(x, y, s) {
      var back, gfxArc, gfxBack;
      SinkTile.__super__.resize.call(this, x, y, s);
      this.removeAllChildren();
      gfxBack = TileGraphics.get('sinkBack');
      if (!gfxBack) {
        gfxBack = new createjs.Graphics().beginFill(Tile.tileBack[this.power]).drawRoundRect(s * Tile.padding * 3, s * Tile.padding * 3, s * (1 - (6 * Tile.padding)), s * (1 - (6 * Tile.padding)), s * Tile.padding * 6);
        TileGraphics.put('sinkBack', gfxBack);
      }
      back = new createjs.Shape(gfxBack);
      back.shadow = Tile.arcShadow[this.power];
      this.addChild(back);
      gfxArc = TileGraphics.get('sinkArc');
      if (!gfxArc) {
        gfxArc = new createjs.Graphics().beginFill(Tile.arcColor).drawCircle(this.midpoint, this.midpoint, s / 16).drawRect(0, this.midpoint - s / 16, this.midpoint, s / 8);
        TileGraphics.put('sinkArc', gfxArc);
      }
      this.arc = new createjs.Shape(gfxArc);
      this.arc.shadow = Tile.arcShadow[this.power];
      this.addChild(this.arc);
      return this;
    };

    return SinkTile;

  })(Tile);

  TubeTile = (function(_super) {
    var outletPaths, outletProbabilities, outletRadians, outletRotations;

    __extends(TubeTile, _super);

    function TubeTile() {
      this.dropTo = __bind(this.dropTo, this);
      this.vanish = __bind(this.vanish, this);
      this.setPower = __bind(this.setPower, this);
      this.spin = __bind(this.spin, this);
      this.onClick = __bind(this.onClick, this);
      this.resize = __bind(this.resize, this);
      this.drawArc = __bind(this.drawArc, this);
      this.setBits = __bind(this.setBits, this);
      _ref2 = TubeTile.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    outletRadians = {
      N: Math.PI / 2,
      E: 0,
      S: 3 * Math.PI / 2,
      W: Math.PI
    };

    outletProbabilities = [
      {
        p: 0.05,
        c: 4,
        n: 1,
        b: [15]
      }, {
        p: 0.50,
        c: 3,
        n: 4,
        b: [7, 11, 13, 14]
      }, {
        p: 0.90,
        c: 2,
        n: 6,
        b: [3, 5, 6, 9, 10, 12]
      }, {
        p: 0,
        c: 1,
        n: 4,
        b: [8, 4, 2, 1]
      }
    ];

    outletPaths = [
      {
        s: 'N',
        d: 'S',
        t: 'L',
        x1: 0,
        y1: -1,
        x2: 0,
        y2: 1
      }, {
        s: 'E',
        d: 'W',
        t: 'L',
        x1: -1,
        y1: 0,
        x2: 1,
        y2: 0
      }, {
        s: 'N',
        d: 'E',
        t: 'A',
        x: 1,
        y: -1,
        a1: outletRadians.N,
        a2: outletRadians.W,
        x1: 0,
        y1: -1,
        x2: 1,
        y2: 0
      }, {
        s: 'E',
        d: 'S',
        t: 'A',
        x: 1,
        y: 1,
        a1: outletRadians.W,
        a2: outletRadians.S,
        x1: 1,
        y1: 0,
        x2: 0,
        y2: 1
      }, {
        s: 'S',
        d: 'W',
        t: 'A',
        x: -1,
        y: 1,
        a1: outletRadians.S,
        a2: outletRadians.E,
        x1: 0,
        y1: 1,
        x2: -1,
        y2: 0
      }, {
        s: 'W',
        d: 'N',
        t: 'A',
        x: -1,
        y: -1,
        a1: outletRadians.E,
        a2: outletRadians.N,
        x1: -1,
        y1: 0,
        x2: 0,
        y2: -1
      }, {
        b: 8,
        t: 'L',
        x1: 0,
        y1: -1,
        x2: 0,
        y2: -1 / 4
      }, {
        b: 4,
        t: 'L',
        x1: 1 / 4,
        y1: 0,
        x2: 1,
        y2: 0
      }, {
        b: 2,
        t: 'L',
        x1: 0,
        y1: 1 / 4,
        x2: 0,
        y2: 1
      }, {
        b: 1,
        t: 'L',
        x1: -1,
        y1: 0,
        x2: -1 / 4,
        y2: 0
      }
    ];

    outletRotations = {
      0: {
        N: 'N',
        E: 'E',
        S: 'S',
        W: 'W'
      },
      90: {
        N: 'E',
        E: 'S',
        S: 'W',
        W: 'N'
      },
      180: {
        N: 'S',
        E: 'W',
        S: 'N',
        W: 'E'
      },
      270: {
        N: 'W',
        E: 'N',
        S: 'E',
        W: 'S'
      }
    };

    TubeTile.prototype.initialize = function(colNum, rowNum, x, y, s, board) {
      var prob, r, _i, _len;
      TubeTile.__super__.initialize.call(this, colNum, rowNum, x, y, s, board);
      r = Math.random();
      this.outletBits = 0;
      this.outletCount = 0;
      for (_i = 0, _len = outletProbabilities.length; _i < _len; _i++) {
        prob = outletProbabilities[_i];
        if ((prob.p === 0) || (r <= prob.p)) {
          this.outletBits = prob.b[Math.floor(Math.random() * prob.b.length)];
          this.outletCount = prob.c;
          break;
        }
      }
      this.setBits(this.outletBits);
      this.spinRemain = 0;
      this.tileSize = s;
      this.resize(x, y, s);
      return this.ready = true;
    };

    TubeTile.prototype.setBits = function(outletBits) {
      this.outletBits = outletBits;
      this.outlets = {
        N: !!(this.outletBits & 8),
        E: !!(this.outletBits & 4),
        S: !!(this.outletBits & 2),
        W: !!(this.outletBits & 1)
      };
      if (this.arc) {
        return this.drawArc();
      }
    };

    TubeTile.prototype.drawArc = function() {
      var gfxArc, path, _i, _len;
      if (this.arc) {
        this.removeChild(this.arc);
      }
      gfxArc = TileGraphics.get('tileArc' + this.outletBits);
      if (!gfxArc) {
        gfxArc = new createjs.Graphics().setStrokeStyle(this.tileSize / 8).beginStroke(Tile.arcColor);
        for (_i = 0, _len = outletPaths.length; _i < _len; _i++) {
          path = outletPaths[_i];
          if (!((('b' in path) && (this.outletBits === path.b)) || (('s' in path) && this.outlets[path.s] && this.outlets[path.d]))) {
            continue;
          }
          gfxArc.moveTo(path.x2 * this.midpoint, path.y2 * this.midpoint);
          switch (path.t) {
            case 'L':
              gfxArc.lineTo(path.x1 * this.midpoint, path.y1 * this.midpoint);
              break;
            case 'A':
              gfxArc.arc(path.x * this.midpoint, path.y * this.midpoint, this.midpoint, path.a1, path.a2, false);
              break;
            default:
              false;
          }
        }
        gfxArc.endStroke();
        TileGraphics.put('tileArc' + this.outletBits, gfxArc);
      }
      this.arc = new createjs.Shape(gfxArc);
      this.arc.shadow = Tile.arcShadow[this.power];
      this.arc.x = this.midpoint;
      this.arc.y = this.midpoint;
      return this.addChild(this.arc);
    };

    TubeTile.prototype.resize = function(x, y, s) {
      var gfxBack;
      TubeTile.__super__.resize.call(this, x, y, s);
      this.tileSize = s;
      this.removeAllChildren();
      gfxBack = TileGraphics.get('tileBack');
      if (!gfxBack) {
        gfxBack = new createjs.Graphics().beginFill(Tile.tileBack[Tile.POWER_NONE]).drawRoundRect(this.tileSize * Tile.padding, s * Tile.padding, s * (1 - (2 * Tile.padding)), s * (1 - (2 * Tile.padding)), s * Tile.padding * 2);
        TileGraphics.put('tileBack', gfxBack);
      }
      this.back = new createjs.Shape(gfxBack);
      this.back.shadow = Tile.arcShadow[this.power];
      this.addChild(this.back);
      this.drawArc();
      return this;
    };

    TubeTile.prototype.onClick = function(evt) {
      if (!this.board.ready) {
        return;
      }
      this.spinRemain++;
      if (this.ready) {
        return this.spin();
      }
    };

    TubeTile.prototype.spin = function() {
      if (this.spinRemain > 0) {
        AsyncSoundManager.play('sh', 0.3);
        this.ready = false;
        this.spinRemain--;
        createjs.Tween.get(this).to({
          scaleX: 0.7,
          scaleY: 0.7
        }, 25).to({
          rotation: this.rotation + 90
        }, 100).to({
          scaleX: 1,
          scaleY: 1
        }, 25).call(this.spin);
        this.setPower(false);
        return this.board.interruptSweep();
      } else {
        if (this.rotation >= 360) {
          this.rotation %= 360;
        }
        this.outletRotation = this.rotation;
        this.board.readyForSweep();
        return this.ready = true;
      }
    };

    TubeTile.prototype.setPower = function(power) {
      var shadow;
      if (power === this.power) {
        return;
      }
      shadow = Tile.arcShadow[power];
      this.arc.shadow = shadow;
      this.back.shadow = shadow;
      this.power = power;
      return this;
    };

    TubeTile.prototype.vanish = function(onGone) {
      this.ready = false;
      this.setPower(Tile.POWER_NONE);
      if (this.board.settled) {
        createjs.Tween.get(this).to({
          alpha: 0,
          scaleX: 0,
          scaleY: 0
        }, 500).call(onGone);
      } else {
        onGone();
      }
      return this;
    };

    TubeTile.prototype.dropTo = function(colNum, rowNum, x, y, onDropped) {
      var dropDone,
        _this = this;
      this.ready = false;
      this.setPower(Tile.POWER_NONE);
      dropDone = function() {
        _this.colNum = colNum;
        _this.rowNum = rowNum;
        _this.id = Tile.makeId(colNum, rowNum);
        onDropped(_this, colNum, rowNum);
        return _this.ready = true;
      };
      if (this.board.settled) {
        createjs.Tween.get(this).to({
          x: x + this.midpoint,
          y: y + this.midpoint
        }, 250).call(dropDone);
      } else {
        this.x = x + this.midpoint;
        this.y = y + this.midpoint;
        dropDone();
      }
      return this;
    };

    return TubeTile;

  })(Tile);

  ProgressBar = (function(_super) {
    __extends(ProgressBar, _super);

    function ProgressBar(progress, w, h) {
      this.progress = progress;
      this.w = w;
      this.h = h;
      this.setProgress = __bind(this.setProgress, this);
      this.resize = __bind(this.resize, this);
      this.initialize = __bind(this.initialize, this);
      this.initialize(this.progress, this.w, this.h);
    }

    ProgressBar.prototype.initialize = function(progress, w, h) {
      this.progress = progress;
      this.w = w;
      this.h = h;
      ProgressBar.__super__.initialize.call(this);
      this.resize(this.w, this.h);
      return this;
    };

    ProgressBar.prototype.resize = function(w, h) {
      var bar, border, gfxBar, gfxBorder, padding;
      this.w = w;
      this.h = h;
      padding = this.h / 8;
      this.removeAllChildren();
      gfxBorder = new createjs.Graphics().beginFill(Tile.arcColor).drawRect(0, 0, this.w, this.h);
      border = new createjs.Shape(gfxBorder);
      border.shadow = Tile.arcShadow[Tile.POWER_NONE];
      this.addChild(border);
      gfxBar = new createjs.Graphics().beginFill('#777').drawRect(padding, padding, (this.w - (padding * 2)) * this.progress, this.h - (padding * 2));
      bar = new createjs.Shape(gfxBar);
      this.addChild(bar);
      return this;
    };

    ProgressBar.prototype.setProgress = function(progress) {
      this.progress = progress;
      return this.resize(this.w, this.h);
    };

    return ProgressBar;

  })(createjs.Container);

  Splash = (function(_super) {
    __extends(Splash, _super);

    function Splash(stage, onComplete) {
      this.stage = stage;
      this.onComplete = onComplete;
      this.resize = __bind(this.resize, this);
      this.initialize = __bind(this.initialize, this);
      this.addSoundToManifest = __bind(this.addSoundToManifest, this);
      this.manifest = [];
      this.progress = null;
      this.lastProgress = 0;
      this.addSoundToManifest('sh');
      this.addSoundToManifest('boom');
      this.initialize();
      this.resize();
    }

    Splash.prototype.addSoundToManifest = function(id) {
      return this.manifest.push({
        id: id,
        src: "audio/tube-" + id + ".ogg|audio/tube-" + id + ".mp3|audio/tube-" + id + ".wav"
      });
    };

    Splash.prototype.initialize = function() {
      var queue,
        _this = this;
      Splash.__super__.initialize.call(this);
      queue = new createjs.LoadQueue();
      queue.installPlugin(createjs.Sound);
      queue.addEventListener('progress', function(evt) {
        var _ref3;
        _this.lastProgress = evt.progress;
        if ((_ref3 = _this.progress) != null) {
          _ref3.setProgress(_this.lastProgress);
        }
        _this.resize();
      });
      return queue.loadManifest(this.manifest);
    };

    Splash.prototype.resize = function() {
      var credit, h, highScore, inst, progress, score, start, title1, title2, totalWidth, tw, w, y,
        _this = this;
      w = this.stage.canvas.width;
      h = this.stage.canvas.height;
      this.removeAllChildren();
      title1 = new createjs.Text('Tube', (w / 10) + 'px Satisfy', Tile.arcColor);
      title1.textAlign = 'right';
      title1.shadow = Tile.arcShadow[Tile.POWER_SOURCED];
      title1.regX = 0;
      title1.regY = title1.getMeasuredHeight() / 2;
      title1.y = h / 6;
      title2 = new createjs.Text('Tastic!', (w / 10) + 'px Satisfy', Tile.arcColor);
      title2.textAlign = 'left';
      title2.shadow = Tile.arcShadow[Tile.POWER_SUNK];
      title2.regX = 0;
      title2.regY = title2.getMeasuredHeight() / 2;
      title2.y = title1.y;
      totalWidth = title1.getMeasuredWidth() + title2.getMeasuredWidth();
      title2.x = title1.x = (w - totalWidth) / 2 + title1.getMeasuredWidth();
      this.addChild(title1);
      this.addChild(title2);
      credit = new createjs.Text('by Rick Osborne', (w / 64) + 'px Kite One', Tile.arcColor);
      credit.alpha = 0.25;
      credit.shadow = Tile.arcShadow[Tile.POWER_NONE];
      credit.textAlign = 'center';
      credit.x = (w / 2) + (totalWidth / 4);
      credit.y = title2.y + (title2.getMeasuredLineHeight() * 0.6);
      credit.regY = 0;
      this.addChild(credit);
      highScore = ScoreKeeper.getHighScore();
      if (highScore > 0) {
        score = new createjs.Text("High Score: " + highScore, (w / 48) + 'px Kite One', Tile.arcColor);
        score.alpha = 0.4;
        score.shadow = Tile.arcShadow[Tile.POWER_NONE];
        score.textAlign = 'center';
        score.x = w / 2;
        score.regY = score.getMeasuredHeight() / 2;
        score.y = h * 2 / 5;
        this.addChild(score);
      }
      y = h * 3 / 5;
      tw = w / 13;
      if (this.lastProgress < 1) {
        progress = new ProgressBar(this.lastProgress, w / 2, title1.getMeasuredLineHeight() / 3);
        progress.x = w / 4;
        progress.y = y;
        return this.addChild(progress);
      } else {
        start = new StartButton(tw * 3, tw, function() {
          return _this.onComplete();
        });
        start.x = w / 2;
        start.regX = tw * 3 / 2;
        start.y = y;
        start.regY = tw / 2;
        this.addChild(start);
        inst = new createjs.Text('Tap the square to complete the connection and start a new game.', (w / 36) + "px Kite One", Tile.arcColor);
        inst.lineWidth = w / 2;
        inst.textAlign = 'center';
        inst.regX = 0;
        inst.regY = 0;
        inst.x = w / 2;
        inst.y = h * 3 / 4;
        return this.addChild(inst);
      }
    };

    return Splash;

  })(createjs.Container);

  StartButton = (function(_super) {
    __extends(StartButton, _super);

    function StartButton(w, h, onStart) {
      this.w = w;
      this.h = h;
      this.onStart = onStart;
      this.readyForSweep = __bind(this.readyForSweep, this);
      this.resize = __bind(this.resize, this);
      this.initialize(this.w, this.h);
    }

    StartButton.prototype.initialize = function(w, h) {
      this.w = w;
      this.h = h;
      StartButton.__super__.initialize.call(this);
      this.resize(this.w, this.h);
      this.ready = true;
      this.settled = true;
      return this;
    };

    StartButton.prototype.resize = function(w, h) {
      var sink, source;
      this.w = w;
      this.h = h;
      source = new SourceTile(0, 1, 0, 0, this.h, this);
      this.addChild(source);
      this.tile = new TubeTile(1, 0, this.w / 3, 0, this.h, this);
      this.tile.setBits(10);
      this.addChild(this.tile);
      sink = new SinkTile(2, 0, this.w * 2 / 3, 0, this.h, this);
      this.addChild(sink);
      return this;
    };

    StartButton.prototype.interruptSweep = function() {};

    StartButton.prototype.readyForSweep = function() {
      var _this = this;
      if (!(this.tile.rotation === 90 || this.tile.rotation === 270)) {
        return;
      }
      return this.tile.vanish(function() {
        return _this.onStart();
      });
    };

    return StartButton;

  })(createjs.Container);

  GameMenu = (function(_super) {
    __extends(GameMenu, _super);

    GameMenu.digitCount = 9;

    function GameMenu(w, h) {
      this.w = w;
      this.h = h;
      this.setScore = __bind(this.setScore, this);
      this.resize = __bind(this.resize, this);
      this.initialize(this.w, this.h);
    }

    GameMenu.prototype.initialize = function(w, h) {
      this.w = w;
      this.h = h;
      GameMenu.__super__.initialize.call(this);
      this.score = 0;
      this.resize(this.w, this.h);
      return this;
    };

    GameMenu.prototype.resize = function(w, h) {
      var back, digit, digitNum, tw, y, _i, _ref3;
      this.w = w;
      this.h = h;
      this.removeAllChildren();
      back = new createjs.Shape();
      back.graphics.beginFill('#000').drawRoundRect(0, 0, this.w, this.h, this.h / 2);
      this.addChild(back);
      this.digits = [];
      y = this.h * TubetasticGame.fontFudge;
      tw = this.w / (GameMenu.digitCount + 1);
      for (digitNum = _i = 0, _ref3 = GameMenu.digitCount - 1; 0 <= _ref3 ? _i <= _ref3 : _i >= _ref3; digitNum = 0 <= _ref3 ? ++_i : --_i) {
        digit = new createjs.Text('0', this.h + 'px Kite One', Tile.arcColor);
        digit.textAlign = 'center';
        digit.regX = 0;
        digit.x = tw * (digitNum + 1);
        digit.y = y;
        digit.lineHeight = this.h;
        this.digits.push(digit);
        this.addChild(digit);
      }
      this.setScore(this.score);
      return this;
    };

    GameMenu.prototype.setScore = function(score) {
      var digitNum, n, _i, _ref3, _results;
      this.score = score;
      n = this.score;
      _results = [];
      for (digitNum = _i = _ref3 = GameMenu.digitCount - 1; _i >= 0; digitNum = _i += -1) {
        this.digits[digitNum].text = n % 10;
        _results.push(n = Math.floor(n / 10));
      }
      return _results;
    };

    return GameMenu;

  })(createjs.Container);

  GameBoard = (function(_super) {
    __extends(GameBoard, _super);

    function GameBoard(stage, sourceCount, hopDepth) {
      this.stage = stage;
      this.sourceCount = sourceCount;
      this.hopDepth = hopDepth;
      this.tileAt = __bind(this.tileAt, this);
      this.powerSweep = __bind(this.powerSweep, this);
      this.interruptSweep = __bind(this.interruptSweep, this);
      this.readyForSweep = __bind(this.readyForSweep, this);
      this.yForRow = __bind(this.yForRow, this);
      this.xForColumn = __bind(this.xForColumn, this);
      this.resize = __bind(this.resize, this);
      this.initialize(this.sourceCount, this.hopDepth);
    }

    GameBoard.prototype.initialize = function(sourceCount, hopDepth) {
      var colNum, row, rowNum, tile, tileType, _i, _j, _ref3, _ref4;
      this.sourceCount = sourceCount;
      this.hopDepth = hopDepth;
      GameBoard.__super__.initialize.call(this);
      this.board = [];
      this.menu = null;
      this.resize();
      for (rowNum = _i = 0, _ref3 = this.sourceCount - 1; 0 <= _ref3 ? _i <= _ref3 : _i >= _ref3; rowNum = 0 <= _ref3 ? ++_i : --_i) {
        row = [];
        for (colNum = _j = 0, _ref4 = this.hopDepth - 1; 0 <= _ref4 ? _j <= _ref4 : _j >= _ref4; colNum = 0 <= _ref4 ? ++_j : --_j) {
          tileType = TubeTile;
          if (colNum === 0) {
            tileType = SourceTile;
          } else if (colNum === this.hopDepth - 1) {
            tileType = SinkTile;
          }
          tile = new tileType(colNum, rowNum, this.xForColumn(colNum), this.yForRow(rowNum), this.tileSize, this);
          this.addChild(tile);
          row.push(tile);
        }
        this.board.push(row);
      }
      this.settled = false;
      this.score = 0;
      this.menu = new GameMenu(this.tileSize * this.hopDepth, this.tileSize * 0.8);
      this.menu.alpha = 0.25;
      this.menu.x = 0;
      this.menu.y = this.yForRow(this.sourceCount) + (this.tileSize * 0.2);
      this.addChild(this.menu);
      this.powerSweep();
    };

    GameBoard.prototype.resize = function() {
      var colNum, row, rowNum, tile, _i, _len, _ref3, _results;
      this.tileSize = Math.floor(Math.min(this.stage.canvas.width / this.hopDepth, this.stage.canvas.height / (this.sourceCount + 1)));
      this.x = Math.floor((this.stage.canvas.width - (this.tileSize * this.hopDepth)) / 2);
      this.y = Math.floor((this.stage.canvas.height - (this.tileSize * (this.sourceCount + 1))) / 2);
      TileGraphics.resize();
      if (this.menu) {
        this.menu.y = this.yForRow(this.sourceCount) + (this.tileSize * 0.2);
        this.menu.resize(this.tileSize * this.hopDepth, this.tileSize * 0.8);
      }
      _ref3 = this.board;
      _results = [];
      for (rowNum = _i = 0, _len = _ref3.length; _i < _len; rowNum = ++_i) {
        row = _ref3[rowNum];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (colNum = _j = 0, _len1 = row.length; _j < _len1; colNum = ++_j) {
            tile = row[colNum];
            _results1.push(tile.resize(this.xForColumn(colNum), this.yForRow(rowNum), this.tileSize));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    GameBoard.prototype.xForColumn = function(colNum) {
      return colNum * this.tileSize;
    };

    GameBoard.prototype.yForRow = function(rowNum) {
      return rowNum * this.tileSize;
    };

    GameBoard.prototype.readyForSweep = function() {
      if (!this.sweepTimer) {
        return this.sweepTimer = setTimeout(this.powerSweep, 125);
      }
    };

    GameBoard.prototype.interruptSweep = function() {
      if (this.sweepTimer) {
        clearTimeout(this.sweepTimer);
        return this.sweepTimer = null;
      }
    };

    GameBoard.prototype.powerSweep = function() {
      var colNum, direction, dropCount, id, neighbor, neither, onVanished, points, rowNum, sourced, sunk, sweepStart, tile, toCheck, toDrop, toRemove, toVanish, vanishCount, _i, _j, _k, _l, _len, _m, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      sweepStart = Date.now();
      this.ready = false;
      toCheck = [];
      for (rowNum = _i = _ref3 = this.sourceCount - 1; _i >= 0; rowNum = _i += -1) {
        toCheck.push(this.board[rowNum][0]);
      }
      sourced = {};
      sunk = {};
      neither = {};
      toRemove = {};
      points = 0;
      for (rowNum = _j = 0, _ref4 = this.sourceCount - 1; 0 <= _ref4 ? _j <= _ref4 : _j >= _ref4; rowNum = 0 <= _ref4 ? ++_j : --_j) {
        for (colNum = _k = 0, _ref5 = this.hopDepth - 1; 0 <= _ref5 ? _k <= _ref5 : _k >= _ref5; colNum = 0 <= _ref5 ? ++_k : --_k) {
          neither[Tile.makeId(colNum, rowNum)] = this.board[rowNum][colNum];
        }
      }
      while (toCheck.length > 0) {
        tile = toCheck.pop();
        if (tile.power !== Tile.POWER_SOURCED) {
          tile.setPower(Tile.POWER_SOURCED);
        }
        sourced[tile.id] = true;
        delete neither[tile.id];
        if (tile instanceof SinkTile) {
          toRemove[tile.id] = tile;
        }
        _ref6 = tile.getConnectedNeighbors();
        for (direction in _ref6) {
          neighbor = _ref6[direction];
          if (!(neighbor.id in sourced)) {
            toCheck.push(neighbor);
          }
        }
      }
      for (rowNum = _l = _ref7 = this.sourceCount - 1; _l >= 0; rowNum = _l += -1) {
        if (!(("" + (this.hopDepth - 1) + "," + rowNum) in sourced)) {
          toCheck.push(this.board[rowNum][this.hopDepth - 1]);
        }
      }
      while (toCheck.length > 0) {
        tile = toCheck.pop();
        if (tile.power !== Tile.POWER_SUNK) {
          tile.setPower(Tile.POWER_SUNK);
        }
        sunk[tile.id] = true;
        delete neither[tile.id];
        _ref8 = tile.getConnectedNeighbors();
        for (direction in _ref8) {
          neighbor = _ref8[direction];
          if ((!(neighbor.id in sourced)) && (!(neighbor.id in sunk))) {
            toCheck.push(neighbor);
          }
        }
      }
      for (id in neither) {
        tile = neither[id];
        if (tile.power !== Tile.POWER_NONE) {
          tile.setPower(Tile.POWER_NONE);
        }
      }
      for (id in toRemove) {
        tile = toRemove[id];
        toCheck.push(tile);
      }
      if (toCheck.length === 0) {
        this.ready = true;
        this.sweepTimer = null;
        this.settled = true;
      }
      vanishCount = 0;
      dropCount = 0;
      toVanish = [];
      toDrop = [];
      onVanished = function() {
        var colX, destRowNum, drop, onDropped, _len, _m, _n, _o, _p, _ref10, _ref11, _ref9, _results;
        vanishCount--;
        if (!(vanishCount <= 0)) {
          return;
        }
        onDropped = function(tile, colNum, rowNum) {
          dropCount--;
          _this.board[rowNum][colNum] = tile;
          if (!(dropCount <= 0)) {
            return;
          }
          return setTimeout(_this.powerSweep, 0);
        };
        for (colNum = _m = 1, _ref9 = _this.hopDepth - 2; 1 <= _ref9 ? _m <= _ref9 : _m >= _ref9; colNum = 1 <= _ref9 ? ++_m : --_m) {
          destRowNum = _this.sourceCount;
          colX = _this.xForColumn(colNum);
          for (rowNum = _n = _ref10 = _this.sourceCount - 1; _n >= 0; rowNum = _n += -1) {
            tile = _this.board[rowNum][colNum];
            if (tile.id in toRemove) {
              _this.board[rowNum][colNum] = null;
              _this.removeChild(tile);
            } else {
              destRowNum--;
              if (destRowNum > rowNum) {
                dropCount++;
                toDrop.push({
                  tile: tile,
                  colNum: colNum,
                  rowNum: destRowNum,
                  colX: colX
                });
                _this.board[rowNum][colNum] = null;
              }
            }
          }
          for (rowNum = _o = _ref11 = destRowNum - 1; _o >= 0; rowNum = _o += -1) {
            dropCount++;
            tile = new TubeTile(-2, -2, colX, _this.yForRow(rowNum - destRowNum), _this.tileSize, _this);
            toDrop.push({
              tile: tile,
              colNum: colNum,
              rowNum: rowNum,
              colX: colX
            });
            _this.addChild(tile);
          }
        }
        _results = [];
        for (_p = 0, _len = toDrop.length; _p < _len; _p++) {
          drop = toDrop[_p];
          _results.push(drop.tile.dropTo(drop.colNum, drop.rowNum, drop.colX, _this.yForRow(drop.rowNum), onDropped));
        }
        return _results;
      };
      while (toCheck.length > 0) {
        tile = toCheck.pop();
        toRemove[tile.id] = tile;
        _ref9 = tile.getConnectedNeighbors();
        for (direction in _ref9) {
          neighbor = _ref9[direction];
          if (!(neighbor.id in toRemove)) {
            toCheck.push(neighbor);
          }
        }
        if (!(tile instanceof TubeTile)) {
          continue;
        }
        toVanish.push(tile);
        vanishCount++;
      }
      for (_m = 0, _len = toVanish.length; _m < _len; _m++) {
        tile = toVanish[_m];
        tile.vanish(onVanished);
        points++;
      }
      if (this.settled) {
        this.score += points;
        this.menu.setScore(this.score);
        ScoreKeeper.setScore(this.score);
      }
      return this;
    };

    GameBoard.prototype.tileAt = function(colNum, rowNum) {
      if ((colNum >= 0) && (colNum < this.hopDepth) && (rowNum >= 0) && (rowNum < this.sourceCount)) {
        return this.board[rowNum][colNum];
      }
      return null;
    };

    return GameBoard;

  })(createjs.Container);

  TubetasticGame = (function() {
    TubetasticGame.fontFudge = (function() {
      switch (false) {
        case !(navigator.userAgent.indexOf('Safari') > -1):
          return -0.166667;
        case !(navigator.userAgent.indexOf('Firefox') > -1):
          return 0.166667;
        default:
          return 0;
      }
    })();

    function TubetasticGame(canvasName) {
      this.loaded = __bind(this.loaded, this);
      var _this = this;
      SeedRandom.init(Math.random());
      this.stage = new createjs.Stage(canvasName);
      createjs.Ticker.setFPS(30);
      createjs.Ticker.useRAF = true;
      createjs.Ticker.addEventListener('tick', function() {
        return _this.stage.update();
      });
      this.splash = new Splash(this.stage, this.loaded);
      this.stage.addChild(this.splash);
      this.board = null;
      createjs.Touch.enable(this.stage, true, false);
      window.onresize = function() {
        var backingStoreRatio, context, devicePixelRatio, ratio, _ref3, _ref4;
        context = _this.stage.canvas.getContext('2d');
        devicePixelRatio = window.devicePixelRatio || 1;
        backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        ratio = devicePixelRatio / backingStoreRatio;
        if (devicePixelRatio === backingStoreRatio) {
          ratio = 1;
        }
        _this.stage.canvas.width = window.innerWidth * ratio;
        _this.stage.canvas.height = window.innerHeight * ratio;
        context.scale(ratio, ratio);
        if ((_ref3 = _this.board) != null) {
          _ref3.resize();
        }
        return (_ref4 = _this.splash) != null ? _ref4.resize() : void 0;
      };
      window.onresize();
    }

    TubetasticGame.prototype.loaded = function() {
      this.stage.removeAllChildren();
      this.splash = null;
      this.board = new GameBoard(this.stage, 8, 7);
      return this.stage.addChild(this.board);
    };

    return TubetasticGame;

  })();

  new TubetasticGame('gameCanvas');

}).call(this);
